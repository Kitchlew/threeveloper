# 003. @react-three/fiber basics

## Introduction

Have you ever seen a 3D website that impressed you so much that you wanted to learn how to do this yourself? Then try out react-three-fiber by following this course, where we will go over the basics, which will help you to create your 3D websites faster. react-three-fiber is based on three.js, so be aware that this video might be a bit hard to follow if you don't have any experience with three.js yet.

We will start by using the code base that we created in a previous video which is linked in the top right corner.

When we look at our code, the base of the ThreeScene function is a Canvas. This will always be the root element of your react-three-fiber content. Why is this element needed and what does it do exactly? Let's dive deeper into that. To be able to display anything with three.js, you need at least three things:

- A scene, which is basically the universe where all 3D objects will be placed in. This will have an X, Y and Z axis for the width, height and depth of the universe.
- We will need a camera to show the scene from a specific point
- And a renderer which is being used to actually render the scene from the camera viewpoint

In this code example you get to see that our simple Canvas JSX element generates all of those requirements in the background. First, it creates the scene, camera and renderer we mentioned before. Then the renderer gets connected to the HTML canvas which is generated by react-three-fiber. The mesh that we added manually will be added to the scene and finally the animation loop will be added. It's good to notice that in three.js we would have to develop all of this code ourselves.

But as you might have noticed, we also included lights in our own codebase. Let's add a property to this light, so we can see that it automatically brightens up the cube. So, what exactly happens here? For that, let's look at some simplified code. In case you add a pointLight with the args property included, it will actually create a three.js pointlight in the background with those args as constructor parameters. In case we set the intensity, react-three-fiber will create a default pointlight and set the intensity to the provided value. Something similar happens when you set the position with an array of value, but here it calls the set method to set the position. So, how does r3f know to use the set method in this case, while it uses the single equals assignment operator for the intensity? This is because r3f automatically checks if there is a set method available to call. In case you only want to set a single property of for example the position, you can do this by setting the react property using a dash instead of a dot.  There are some other relevant properties and automatic checks, but those will be handled in another video, since this is getting too complex for the basics.

Before we continue, I want to note that 83% of the viewers isn't subscribed yet. It would mean a lot to me if you could subscribe to help this channel grow and to remove the lack of content about react-three-fiber on youtube.

Let's get back on the picture about rendering the scene. It shows an X, Y and Z axis, which are not visible in our website. So how can we know which direction is X, Y or Z? For that, an easy solution is the AxesHelper, which react-three-fiber provides by default. Add an argument for the length of the axes and save your file. You will get to see a red X axis and a green Y axis, but there is no blue Z axis yet. This is because the Z axis is pointed exactly towards us. To be able to see this, we will need to move our camera. We can do this by using some sort of controls. In three.js, there is an OrbitControls class available, which makes it possible to drag around the center of the scene. This class needs a camera and a domElement as arguments, which we can retrieve by using the useThree hook. As you see, the orbitControls element does not exist by default in r3f. Luckily, it provides an extend method we can use to add the orbitControls to the react intrinsic elements. To seperate this code, let's create a r3f-elements.ts file, add the required imports and extend the OrbitControls class. This will fix our problem, but because we are using TypeScript, we will need to add the orbitControls to the IntrinsicElements interface inside of the global JSX namespace.

As you see, this will fix the error, which is actually a false positive. TypeScript catches the declaration we added, but the file hasn't been included in our project yet. Therefore we need to import it in our main file. Add the Controls to the Canvas and you will be able to drag around inside of our scene. This way, you will also get to see the blue Z axis.

Now, you might have noticed that I created a seperate function for the Controls. That's because our code will break if we add the element and required code to our ThreeScene function, as you see here: React-three-fiber hooks can only be used within the Canvas component. In our case, this is exactly what we did wrong with the useThree hook.

This is because of something called React Context, which can not be used between multiple renderers. Since react-three-fiber is a seperate react renderer, it cannot access the context without being inside of the canvas.

This caveat is very unfortunate, but let's end with some good news: luckily, this is the only gotcha you will find on the official react-three-fiber website.

Hopefully this gave you a clear idea of the basics of react-three-fiber. If you think this was too complex or you prefer more three.js context within those tutorials, please let me know in the comments down below. Also if you have any other requests or questions, I am available to help. If you haven't seen my other video's, here are some suggestions. Thanks for your time and I will see you next time, Ciao!